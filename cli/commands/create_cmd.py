"""
Starlight CLI - Create Command
Generates a new Sentinel boilerplate file.
"""

import os
import re


SENTINEL_TEMPLATE = '''"""
{class_name} - Custom CBA Sentinel
Generated by Starlight CLI

Monitors for specific conditions and responds during the pre-check phase.
"""

import asyncio
import sys
import os

# Path boilerplate for local imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from sdk.starlight_sdk import SentinelBase


class {class_name}(SentinelBase):
    def __init__(self):
        super().__init__(layer_name="{class_name}", priority=5)
        # Define what DOM patterns this sentinel monitors
        self.selectors = []
        # Define capabilities for Hub coordination
        self.capabilities = []
    
    async def on_pre_check(self, params, msg_id):
        """
        Called before each command execution.
        Analyze the environment and decide: CLEAR, WAIT, or HIJACK.
        
        Args:
            params: Contains 'command', 'blocking' elements, optional 'screenshot'
            msg_id: Message ID for response correlation
        """
        cmd = params.get("command", {{}}).get("cmd", "unknown")
        blocking = params.get("blocking", [])
        
        # TODO: Implement your detection logic here
        # Example: Check if any blocking elements match your selectors
        
        # If environment is safe:
        print(f"[{{self.layer}}] Environment clear for: {{cmd}}")
        await self.send_clear()
        
        # If you need more time (instability detected):
        # await self.send_wait(1000)  # Wait 1 second
        
        # If you need to take control (obstacle found):
        # await self.send_hijack("Detected obstacle that needs clearing")
        # await self.send_action("click", "#close-button")
        # await self.send_resume()
    
    async def on_entropy(self, params):
        """
        Called when DOM/Network activity is detected.
        Use this for stability monitoring.
        """
        pass
    
    async def on_context_update(self, context):
        """
        Called when the Hub broadcasts shared state updates.
        Use this to receive intelligence from other Sentinels.
        """
        pass


if __name__ == "__main__":
    sentinel = {class_name}()
    asyncio.run(sentinel.start())
'''


def to_pascal_case(name: str) -> str:
    """Convert a name to PascalCase for class naming."""
    # Remove any non-alphanumeric characters and split
    words = re.split(r'[_\-\s]+', name)
    return ''.join(word.capitalize() for word in words)


def execute(name: str):
    """Generate a new Sentinel file."""
    # Normalize name
    name_lower = name.lower().replace("-", "_").replace(" ", "_")
    class_name = to_pascal_case(name) + "Sentinel"
    filename = f"{name_lower}_sentinel.py"
    
    # Determine sentinels directory
    sentinels_dir = os.path.join(os.getcwd(), "sentinels")
    
    if not os.path.exists(sentinels_dir):
        print(f"[Starlight] Creating sentinels/ directory...")
        os.makedirs(sentinels_dir)
    
    filepath = os.path.join(sentinels_dir, filename)
    
    if os.path.exists(filepath):
        print(f"[Starlight] ERROR: Sentinel '{filename}' already exists.")
        return False
    
    # Generate sentinel file
    content = SENTINEL_TEMPLATE.format(class_name=class_name)
    
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content)
    
    print(f"[Starlight] Created new Sentinel: sentinels/{filename}")
    print(f"  Class: {class_name}")
    print(f"\nNext steps:")
    print(f"  1. Edit sentinels/{filename} to add your detection logic")
    print(f"  2. Add selectors to monitor: self.selectors = ['.modal', '#popup']")
    print(f"  3. Run with: python sentinels/{filename}")
    
    return True
